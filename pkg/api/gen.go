// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gorilla/mux"
	"github.com/oapi-codegen/runtime"
)

// AliasDetail Alias detail
type AliasDetail struct {
	// Create Whether create is allowed underneath this alias
	Create *bool `json:"create,omitempty"`

	// Delete Whether delete is allowed underneath this alias
	Delete *bool `json:"delete,omitempty"`

	// Name Alias name
	Name *string `json:"name,omitempty"`

	// Path ROSAPI path within device
	Path string `json:"path"`

	// Update Whether update is allowed underneath this alias
	Update *bool `json:"update,omitempty"`
}

// AliasList List of aliases
type AliasList = []AliasDetail

// DeviceDetail Device detail
type DeviceDetail struct {
	// Address Device address in form of <host/IP>:<port>, such as "192.168.0.20:1234"
	Address string `json:"address"`

	// Name Device symbolic name
	Name     *string `json:"name,omitempty"`
	Password string  `json:"password"`

	// Timeout Connection timeout in seconds
	Timeout *float32 `json:"timeout,omitempty"`

	// Tls Device TLS configuration. When not present, TLS won't be used
	Tls      *DeviceTlsConfig `json:"tls,omitempty"`
	Username string           `json:"username"`
}

// DeviceList List of names
type DeviceList = []DeviceDetail

// DeviceTlsConfig Device TLS configuration. When not present, TLS won't be used
type DeviceTlsConfig struct {
	// Ca Path to CA certificate
	Ca *string `json:"ca,omitempty"`

	// Verify whether a client verifies the server's certificate chain and host name.
	Verify bool `json:"verify"`
}

// Item Dictionary of name-to-value.
type Item map[string]string

// ItemList List of items
type ItemList = []Item

// Alias defines model for alias.
type Alias = string

// Device defines model for device.
type Device = string

// Id defines model for id.
type Id = string

// CreateItemJSONRequestBody defines body for CreateItem for application/json ContentType.
type CreateItemJSONRequestBody = Item

// PatchItemJSONRequestBody defines body for PatchItem for application/json ContentType.
type PatchItemJSONRequestBody = Item

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all configured aliases
	// (GET /config/aliases)
	ListAliases(w http.ResponseWriter, r *http.Request)
	// List all configured devices
	// (GET /config/devices)
	ListDevices(w http.ResponseWriter, r *http.Request)
	// List all items under path
	// (GET /data/{device}/{alias})
	ListItems(w http.ResponseWriter, r *http.Request, device Device, alias Alias)
	// Create a new item
	// (POST /data/{device}/{alias})
	CreateItem(w http.ResponseWriter, r *http.Request, device Device, alias Alias)
	// Delete a single item
	// (DELETE /data/{device}/{alias}/{id})
	DeleteItem(w http.ResponseWriter, r *http.Request, device Device, alias Alias, id Id)
	// Get a single item
	// (GET /data/{device}/{alias}/{id})
	GetItem(w http.ResponseWriter, r *http.Request, device Device, alias Alias, id Id)
	// Update properties of single item
	// (PATCH /data/{device}/{alias}/{id})
	PatchItem(w http.ResponseWriter, r *http.Request, device Device, alias Alias, id Id)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListAliases operation middleware
func (siw *ServerInterfaceWrapper) ListAliases(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAliases(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListDevices operation middleware
func (siw *ServerInterfaceWrapper) ListDevices(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDevices(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListItems operation middleware
func (siw *ServerInterfaceWrapper) ListItems(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "device" -------------
	var device Device

	err = runtime.BindStyledParameterWithOptions("simple", "device", mux.Vars(r)["device"], &device, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "device", Err: err})
		return
	}

	// ------------- Path parameter "alias" -------------
	var alias Alias

	err = runtime.BindStyledParameterWithOptions("simple", "alias", mux.Vars(r)["alias"], &alias, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "alias", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListItems(w, r, device, alias)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateItem operation middleware
func (siw *ServerInterfaceWrapper) CreateItem(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "device" -------------
	var device Device

	err = runtime.BindStyledParameterWithOptions("simple", "device", mux.Vars(r)["device"], &device, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "device", Err: err})
		return
	}

	// ------------- Path parameter "alias" -------------
	var alias Alias

	err = runtime.BindStyledParameterWithOptions("simple", "alias", mux.Vars(r)["alias"], &alias, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "alias", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateItem(w, r, device, alias)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteItem operation middleware
func (siw *ServerInterfaceWrapper) DeleteItem(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "device" -------------
	var device Device

	err = runtime.BindStyledParameterWithOptions("simple", "device", mux.Vars(r)["device"], &device, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "device", Err: err})
		return
	}

	// ------------- Path parameter "alias" -------------
	var alias Alias

	err = runtime.BindStyledParameterWithOptions("simple", "alias", mux.Vars(r)["alias"], &alias, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "alias", Err: err})
		return
	}

	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteItem(w, r, device, alias, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetItem operation middleware
func (siw *ServerInterfaceWrapper) GetItem(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "device" -------------
	var device Device

	err = runtime.BindStyledParameterWithOptions("simple", "device", mux.Vars(r)["device"], &device, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "device", Err: err})
		return
	}

	// ------------- Path parameter "alias" -------------
	var alias Alias

	err = runtime.BindStyledParameterWithOptions("simple", "alias", mux.Vars(r)["alias"], &alias, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "alias", Err: err})
		return
	}

	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetItem(w, r, device, alias, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PatchItem operation middleware
func (siw *ServerInterfaceWrapper) PatchItem(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "device" -------------
	var device Device

	err = runtime.BindStyledParameterWithOptions("simple", "device", mux.Vars(r)["device"], &device, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "device", Err: err})
		return
	}

	// ------------- Path parameter "alias" -------------
	var alias Alias

	err = runtime.BindStyledParameterWithOptions("simple", "alias", mux.Vars(r)["alias"], &alias, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "alias", Err: err})
		return
	}

	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchItem(w, r, device, alias, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{})
}

type GorillaServerOptions struct {
	BaseURL          string
	BaseRouter       *mux.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r *mux.Router) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r *mux.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options GorillaServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = mux.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.HandleFunc(options.BaseURL+"/config/aliases", wrapper.ListAliases).Methods("GET")

	r.HandleFunc(options.BaseURL+"/config/devices", wrapper.ListDevices).Methods("GET")

	r.HandleFunc(options.BaseURL+"/data/{device}/{alias}", wrapper.ListItems).Methods("GET")

	r.HandleFunc(options.BaseURL+"/data/{device}/{alias}", wrapper.CreateItem).Methods("POST")

	r.HandleFunc(options.BaseURL+"/data/{device}/{alias}/{id}", wrapper.DeleteItem).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/data/{device}/{alias}/{id}", wrapper.GetItem).Methods("GET")

	r.HandleFunc(options.BaseURL+"/data/{device}/{alias}/{id}", wrapper.PatchItem).Methods("PATCH")

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
